---
layout: post
title: Binary Search
date: 2021-07-01
category: Algorithm
use_math: true
---

이전 문서에서 이진 탐색은 데이터가 정렬된 상태에서 적용가능하다고 했으며 선택 정렬, 삽입 정렬, 퀵 정렬, 계수 정렬을 공부했다. 이번에는 리스트 내에서 데이터를 매우 빠르게 탐색하는 이진 탐색 알고리즘에 대해 알아 본다. 

---

### 1. 순차 탐색 (Sequential Search)

이진 탐색 전에 순차 탐색을 이해해야 한다. 순차 탐색은 리스트 안에 있는 특정한 데이터를 찾기 위해 <mark>앞에서부터 데이터를 하나씩 차례대로 확인</mark>하는 방법이다. 보통 정렬되지 않은 리스트에서 데이터를 찾을 때 사용하며, 리스트 내에 데이터가 아무리 많아도 시간만 충분하다면 항상 원하는 데이터를 찾을 수 있다. 순차 탐색은 다음과 같이 구현할 수 있다. 

```python
# 순차 탐색
def sequential_search(n, target, array):
    for i in range(n):   # 각 원소를 하나씩 앞에서부터 확인
        if array[i] == target:  # 찾고자 하는 원소와 같으면 
            return i+1  # 그 데이터의 위치 반환 (인덱스는 0부터 시작하므로 1 더하기)

# 데이터의 원소 개수와 찾을값을 입력받기
input_data = input().split()
n = int(input_data[0])
target = input_data[1]
# 데이터 입력 받기
array = input().split()

# 순차 탐색 진행
print(sequential_search(n, target, array))

'''
5 c
d f e c s
4
'''
```

순차 탐색은 리스트에 특정 값의 원소가 있는지 체크할 때 사용하고, 리스트 자료형의 count() 메서드를 이용할 때도 내부에서는 순차 탐색이 수행된다. 

#### 시간 복잡도: 최악 O(N)

순차 탐색은 데이터 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인한다. 따라서 데이터의 개수가 N개 일때 최대 N번의 비교 연산이 필요하므로 최악의 경우 시간 복잡도는 O(N)이다. 

---

### 2. 이진 탐색 (Binary Search)

이진 탐색은 <mark>배열이 정렬되어 있어야만 사용</mark>할 수 있다. 이진 탐색은 <mark>찾으려는 데이터와 중간에 있는 데이터를 반복적으로 비교하며 탐색 범위를 절반씩 좁혀가며 데이터를 탐색</mark>한다. 

다음은 정렬된 데이터에서 값이 4인 원소를 찾는 예시이다.

![image](https://user-images.githubusercontent.com/61526722/124065264-5eb4d100-da71-11eb-8a86-9c5868c8e95f.png)

이처럼 이진 탐색을 이용해 총 3번의 탐색으로 원소를 찾을수 있다. 

이진 탐색은 <mark>재귀함수나 반복적 구현</mark> 두 가지 방법으로 구현할 수 있다.

```python

```

#### 시간 복잡도: O(logN)

이진 탐색은 한번 확인할 때마다 확인하는 원소의 개수가 절반씩 줄어든다. 예를 들어 데이터의 개수가 32개일 때, 1단계 거치면 16개, 2단계 거치면 8개..개량의 데이터만 확인하면 된다. 절반씩 데이터를 줄어들도록 만든다는 것은 퀵 정렬과 공통점이 있다. 

---

### 3. 이진 탐색 트리


[참고](https://yeji-shin.github.io/datastructure/2021/07/02/8.-Tree.html)






















