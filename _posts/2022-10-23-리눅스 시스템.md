---
layout: post
title: 리눅스 시스템
date: 2022-10-23
category: Linux
---

### 파일 I/O

파일은 리눅스 운영체제에서 가장 기본적이고 핵심이 되는 추상화 개념이다. 장치, 파일, 디렉토리 모두 파일로 인식할 수 있다. 리눅스의 모든 것은 파일이다. 

**파일 디스크립터**

리눅스에서는 특정 파일을 정수(int)로 인식한다. 파일 디스크립터는 프로세스의 열린 파일을 고유하게 식별하는 정수(int) 이다.

**파일 디스크립터 테이블**

파일 디스트립터는 파일 테이블 엔트리들을 가리키는 포인터이고, 이 파일 디스크립터를 가리키는 정수 배열의 집합을 파일 디스크립터 테이블이라고 한다. 운영 체제에서는 각 프로세스마다 하나의 고유한 파일 디스크립터 테이블이 제공된다. 

**파일 테이블 엔트리**

파일 테이블 엔트리는 메모리내에 존재하는 열린 파일에 대한 구조체이다. 이는 파일을 열거나 파일 위치를 유지 보수할 때 생성된다. 

**표준 파일 디스크립터**

프로세스가 시작되면 해당 프로세스 파일 디스크립터 테이블의 파일 디스크립터 0, 1, 2 가 자동으로 열린다. 

- 0 (stdin) : 키보드에서 문자를 쓸 때마다 fd 0 을 통해 stdin으로 부터 읽어 들인다.
- 1 (stdout) : fd 1을 통해 화면의 stdout에 쓸 때마다 화면 출력에 나타난다.
- 2 (stderr) : fd 2 를 통해 화면의 stderr에 쓸 때마다 화면에 에러 출력이 나타난다.

---

### 표준 I/O 라이브러리

파일 I/O는 리눅스 커널 지원 시스템 콜이고, 표준 I/O 라이브러리는 어플리케이션 수준의 시스템 콜이다. 

**사용자 버퍼 입출력**
사용자 버퍼 입출력은 블록 단위로 동작하는 파일 시스템과 추상 개념을 갖고 있는 애플리케이션 간의 간극을 좁혀준다. 데이터가 쓰여지면 프로그램 주소 공간 내 버퍼에 저장되고, 버퍼가 특정 크기(버퍼 크기)에 도달하면 전체 버퍼는 한번의 쓰기 연산을 통해 실제로 기록이 된다. 읽기 역시 마찬가지로 버퍼 크기에 맞춰 블록에 정렬된 데이터를 읽는다.

그 결과 데이터가 많더라도 모두 블록 크기에 맞춰 적은 횟수의 시스템 콜만 사용하게 되며 이를 통해 성능 향상을 얻을 수 있다. 표준 C 라이브러리가 제공하는 stdio 라이브러리는 플랫폼 독립적인 사용자 버퍼링 해법을 제공한다.

---

### 프로세스

리눅스의 모든 것이 파일이었다면, 프로세스는 리눅스에서 실행 중인 모든 프로그램을 의미한다. 프로세스는 메모리에 로딩중인 프로그램 이미지, 가상 메모리 인스턴스, 열린 파일 디스크립터 같은 커널 리소스, 사용자 정보, 하나 이상의 스레드 등을 포함하고 있다. 일반적으로 프로세스를 수행하면 메인 스레드라는 기본적인 스레드가 수행되는 것이다. 

**프로세스 ID**
모든 프로세스는 프로세스 ID(pid) 라고 하는 유일한 식별자로 구분된다. (특정 시점에 unique)

**부모/자식 프로세스**
새로운 프로세스를 생성하는 프로세스를 부모 프로세스라고 하고, 새롭게 생성된 프로세스를 자식 프로세스라고 한다. 리눅스 운영체제는 부팅 시 0번 프로세스인 init 프로세스를 수행시키고, 부팅 프로세스에 따라 init 프로세스가 다른 필요한 프로세스들을 생성한다. (ex. bash) 따라서 사실상 리눅스 운영체제에서 돌아가는 모든 프로세스의 부모는 init 프로세스가 된다. 

bash 프로세스의 부모 프로세스는 init(0) 프로세스가 된다. 최신 CentOS의 경우 init(0)이 systemd 프로세스를 1번으로 생성하고 systemd 프로세스가 대부분의 어플리케이션 레이어의 프로세스 들을 실행한다. 쉘(bash)에서 실행한 특정 프로그램의 부모 프로세스는 bash 프로세스가 된다.

`**ps -ef**` 

현재 수행중인 프로세스들의 목록을 확인할 수 있으며, PID(프로세스 ID), PPID(부모 프로세스 ID) 등을 확인할 수 있다.

---

### 스레드

스레드는 프로세스의 내부에서 실행되는 흐름의 단위이다. 일반적으로 하나의 프로그램(프로세스)는 하나의 스레드를 가지지만, 두 개 이상의 스레드를 동시에 실행할 수도 있다. 이것을 멀티스레드라고 한다. 

![image](https://user-images.githubusercontent.com/61526722/197386370-65f64c6e-6ed1-44d4-9710-ae6218b8039c.png)

예를 들어 어떤 신호나 데이터 입력을 기다리다가 입력이 들어오면 입력 데이터를 분석하여, 분석의 결과를 특정 파일에 기록하는 프로그램이 있을 때, 여러 입력을 병렬적으로 처리할 수 있는 방법중에 하나가 스레드(Thread) 이다. 입력 데이터를 읽어서 처리하는 스레드가 존재하면, 입력 데이터를 인지할 때마다 이후 처리를 다른 스레드에게 맡기고, 다시 입력 데이터를 인지할 수 있다. 즉, 여러 입력 데이터를 처리하는 스레드가 동시에 여러개가 동작하는 것이다.

**다중 프로세스 vs 다중 스레드 차이**
다중 프로세스의 경우 프로세스간 데이터 공유를 위하여 IPC 등의 매커니즘을 이용하여 데이터를 공유하고, 다중 스레드의 경우 프로세스 내에서 전역 변수 등 데이터를 공유한다. 다중 프로세스의 경우 프로세스간의 컨택스트 스위칭 시 다중 스레드보다 많은 비용을 소모하므로, 다중 스레드가 좀 더 빠를 수 있고 메모리 공유로 인하여 메모리를 절약할 수 있다.

**프로세스 컨택스트 스위칭**
특정 CPU에서 A라는 프로세스가 돌아가다가 B라는 프로세스 작업을 처리해야하는 경우, A 프로세스를 위해 가지고 있던 가상 메모리 공간, 버퍼 등을 비우고 B 프로세스를 위한 가상 메모리 공간, 버퍼 등을 준비해야 한다. 이 처리를 컨택스트 스위칭이라 한다.

**주의할 점**
동일한 프로세스의 다중 스레드의 경우 공유된 리소스에 동시 접근할 경우 동기화에 주의해야 한다.
경쟁상태에서 데이터의 원자성이 깨지거나, 동기화 락 사용 시 데드락 등에 주의해야 한다.

---

### 시그널

시그널은 일반적으로 유닉스 계열의 POSIX 호환 운영체제에서 사용되는 제한된 형태의 프로세스 간 통신(IPC) 입니다. 시그널은 발생한 이벤트를 알리기 위해 프로세스 또는 동일한 프로세스 내의 특정 스레드로 전송되는 비동기 알림 입니다. 시그널이 전송되면 운영체제는 대상 프로세스의 정상적인 실행 흐름을 중단하여 시그널을 전달받아 시그널에 대한 처리를 한다. 프로세스가 시그널 핸들러를 등록한 경우 해당 루틴이 실행되고 그렇지 않으면 기본 핸들러가 실행됩니다.

![image](https://user-images.githubusercontent.com/61526722/197386378-d9985c1a-0075-4095-9861-c07403b0cc36.png)

**시그널 전송**

- 권한이 허용되는 경우 kill() 시스템 콜은 지정된 신호를 지정된 프로세스에 전송
- kill 명령을 사용하면 사용자가 프로세스에 신호를 전송
- raise() 라이브러리 함수는 지정된 신호를 현재 프로세스에 전송
- 0으로 나누기(SIGFPE) 또는 세그먼테이션 폴트(SIGSEGV)와 같은 예외는 신호를 생성
- 커널은 프로세스에 이벤트를 알리기 위해 신호를 생성할 수 있음 (SIGPIPE 등)
- 실행중인 프로세스의 제어 터미널에 특정 키 조합을 입력하면 시스템이 특정 신호를 전송 (ex. Ctrl+C로 프로세스 죽이기)

**시그널 처리**
커널은 프로세스의 현재 코드 실행을 중단하고, 이전에 등록했던 시그널 핸들러 함수로 건너뛴다. 시그널 핸들러 함수 실행 후 리턴되면 프로세스는 시그널을 붙잡은 시점으로 돌아간다. 시그널 핸들러는 signal() 또는 sigaction() 시스템 콜과 함께 지정할 수 있다. 시그널 핸들러가 특정 시그널에 대해 지정되지 않은 경우 기본 핸들러가 사용된다. 프로세스는 시그널 핸들러를 지정하지 않고 두 가지 기본 동작을 지정할 수도 있다.
SIG_IGN - 시그널 무시
SIG_DFL - 기본 시그널 핸들러

---

### IPC

여러 프로세스가 동시에 실행되고 있을 때 프로세스끼리 데이터를 주고 받을 수 있다. 프로세스 간 통신(IPC, Inter-Process Communication)은 프로세스들 사이에 서로 데이터를 주고받는 행위나 그에 대한 방법을 의미한다. 주요 IPC 방식은 파일, 시그널, 익명 파이프, 지명 파이프, 메모리 매핑 파일, 공유 메모리, 메시지 큐, 소켓 이다. 

**익명 파이프**

파이프 한쪽에서 물을 흘리면 반대쪽 파이프에서 물이 흘러나오는 것과 같다. 한쪽에서 데이터를 흘리면 다른 한쪽에서 데이터를 받을 수 있다. 파이프에는 익명 파이프(anonymous pipe)와 지명 파이프(named pipe), 2종류가 있다.

익명 파이프는 서로 관련된 프로세스들만 공유할 수 있고, 지명 파이프는 관련이 없는 프로세스들도 공유할 수 있다. 지명 파이프를 유닉스에서 구현하면서 FIFO로 이름을 붙였기 때문에 FIFO라 하면 지명 파이프를 의미하고, 그냥 파이프라고 하면 익명 파이프를 의미한다. 

쉘에서 명령을 수행할 때 버티컬 바('|') 문자를 사용하여 하나의 프로세스 출력을 다른 프로세스의 입력으로 연결할 수 있다.

![image](https://user-images.githubusercontent.com/61526722/197386390-de0abecc-edd0-4aad-8d93-1d880d53ce04.png)

---

### 시간

현재 시간을 획득하여 로그와 같은 정보를 출력한다던지, 일정 시간을 기다리는 루틴을 작성한다던지, 혹은 특정 기능이 수행한 시간을 감시한다던지 등 시간에 대한 개념을 활용하여 많은 유용한 프로그램을 개발하는 경우가 많다. 

리눅스 시스템에서의 시간은 1970년 1월 1일 00:00:00 UTC (협정 세계시, Universal Time Coordinate)로 정의된 기원(epoch)부터 경과된 절대 시간을 초로 표현한다.
