---
layout: post
title: 2. Linked List
date: 2021-06-30
category: DataStructure
use_math: true
---

### 1. Linked List 

리스트는 데이터에 순서를 매겨 늘어놓은 자료구조이다. 기본적인 리스트는 모든 원소를 연속으로 메모리에 배치한다. 하지만 연결리스트는 데이터의 순서가 메모리에 물리적인 순서대로 저장되지 않는 자료구조다. 즉, <mark>메모리를 연속적으로 사용하지 않는다</mark>. 실제로 컴퓨터의 물리 메모리에는 서로 연결된 형태로 구성되어 있으며 메모리 어딘가에 여기저기 흩뿌려져있다. 다음은 연결리스트의 기본적이 구조이다.

![image](https://user-images.githubusercontent.com/61526722/123794359-b3dfce00-d91d-11eb-92a6-8294f775f0f6.png)

연결 리스트에서 각각의 원소를 노드라고 한다. 노드가 갖고 있는 것은 데이터와 다음 노드를 가리키는 포인터이다. 맨 앞의 노드를 머리노드, 맨 뒤에 있는 노드를 꼬리 노드라고 한다. 

---

### 2. Array vs Linked List

배열과 연결리스트가 가지는 시간복잡도를 살펴보자. 

#### 데이터 탐색

- 배열: O(1)
- 연결리스트: O(N)

연결리스트는 배열과 달리 특정 인덱스에 접근하기 위해서는 전체를 순서대로 읽어야 하므로 상수 시간에 접근할 수 없다. 즉, 탐색에는 O(N)의 시간이 걸린다. 

반면 배열은 인덱스 번호를 통해서 탐색하기 때문에 O(1)의 시간이 걸린다. 


#### 데이터 추가

먼저 데이터를 추가하는 행위 자체의 시간복잡도는 O(1)이다. 메모리 주소 값만 노드에 할당하면 되기 때문이다. 

- 배열: 최소 O(1), 최대 O(N)
- 연결리스트: 최소 O(1), 최대 O(N)

연결리스트에 추가하려는 데이터의 위치가 맨 앞이라면 O(1) 시간안에 가능하다. 하지만 추가하려는 데이터의 위치가 맨 처음이 아니라면 맨 앞 노드부터 순차적으로 탐색하면서 그 위치까지 가야한다. 따라서 O(N)의 시간복잡도를 가진다.

배열은 데이터들이 메모리상에 순차적으로 저장되어 있다. 따라서 중간에 데이터를 추가할 경우 그 뒤에 있는 데이터들을 전부 한 칸씩 뒤로 밀면서 메모리 할당을 조정해야 한다 O(N). 하지만 맨 뒤에 데이터를 추가할 때는 O(1)안에 실행할 수 있다.  

#### 데이터 삭제

데이터 삭제는 데이터 추가하는 경우와 같다.

- 배열: 최소 O(1), 최대 O(N)
- 연결리스트: 최소 O(1), 최대 O(N)

연결리스트에서 맨 앞의 데이터를 삭제한다면 O(1), 그 뒤의 데이터를 삭제한다면 맨 앞 노드부터 순차적으로 탐색해야 하기 때문에 O(N)이다.

배열에서 맨 뒤의 데이터를 삭제한다면 O(1), 중간의 데이터를 삭제한다면 그 뒤의 데이터들은 한칸씩 앞으로 옮겨줘야 하기 때문에 O(N)이다. 

정리하면 배열은 연속적인 메모리를 할당받아서 데이터를 저장하기 때문에 탐색은 굉장히 빠르다. 반면에 연결리스트는 노드가 있기 때문에 데이터의 추가/삭제가 간편하지만 탐색이 느려졌다. 따라서 <mark>데이터의 탐색이 중요하면 배열, 데이터의 추가/삭제가 중요하다면 연결리스트</mark>를 사용하는 것이 좋다. 

---

### 3. Linked List with Python

이번에는 연결리스트를 파이썬으로 구현해본다. 










