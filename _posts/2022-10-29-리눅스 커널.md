---
layout: post
title: 리눅스 커널 
date: 2022-10-29
category: Linux
---

### 리눅스 커널 구조

커널은 운영체제의 핵심으로 CPU 메모리 장치 등 시스템 자원을 관리한다. 

![image](https://user-images.githubusercontent.com/61526722/198813451-528f6ebd-7fe3-4d61-b7e6-459e41839d26.png)

리눅스 커널이 관리해야할 자원은 크게 CPU, RAM(메모리), 디스크, 터미널, 네트워크 가 있다. 이와 같은 물리적인 자원을 관리하기 위해 커널을 추상화하여 사용하고 있는데, 커널의 주요 동작을 관리 개념으로 나눠보면 프로세스 관리, 메모리 관리, 파일 시스템 관리, 장치 드라이버 관리, 네트워크 관리 등이 있다. 

유저 공간에서 동작하는 어플리케이션이나 툴들은 시스템 콜로 리눅스 커널에 특정 기능을 요청한다. 프로세스 관리자는 멀티태스킹, 메모지 관리자가 가상 메모리, 파일 시스템이 파일이나 디렉토리, 디바이스 드라이버는 특정 장치들과 터미널, 네트워크는 통신을 위한 네트워크를 관리한다. 

커널은 특정 자원을 추상적인 관리 개념으로 추상화하여 사용한다. CPU라는 물리적인 자원을 태스크라는 추상적인 자원으로 제공해주는 프로세스 관리자가 태스크 관리자이다. RAM과 같은 메모리를 세그먼트나 페이지라는 추상적인 자원으로 제공해주는 메모리 관리자, 디스크를 파이라과 같은 개념으로 제공해주는 파일 시스템, 각종 장치를 디바이스 드라이버를 통해 접근할 수 있게 해주는 디바이스 드라이버, 네트워크를 소켓이라는 추상적인 개념으로 제공해주는 네트워크 관리가자 있다. 

결론적으로 운영체제는 사용자에게 서비스를 제공하기 위해 유저의 서비스 요청 시에 자원을 사용할 수 있도록 해주는 역할을 한다. 다시말해 운영체제는 시스템 호출을 통해 시스템 자원을 사용할 수 있게 해주는 자원 관리자인 것이다.   

**리눅스 커널 구성 요소**

리눅스 커널도 일종의 프로그램으로 컴파일을 통해 바이너리로 아웃풋이 나오도록 설계되어 있다. 그 바이너리가 부팅될 때 로딩이 되어 각 역할을 담당하게 된다. 

![image](https://user-images.githubusercontent.com/61526722/198813475-bc0a511c-811c-4e29-95d2-b09d33d571da.png)

- Documentation
    - 커널 소스 코드 문서화
- LICENSES
    - 커널 소스에 적용 할 라이센스와 라이센스가 다른 개별 소스 파일을 포함
    - 이 디렉토리에는 기본 (GNU GPL), COPYING 파일에 나열된 예외 및 기타의 3 가지 하위 디렉토리가 있습니다.
- arch
    - CPU에 종속적인 아키텍처의 소스 코드 (예 : powerpc, x86 등)
    - 이 디렉토리에는 i386, sparc, arm 등 지원되는 각 아키텍처에 속하는 서브 디렉토리가 있습니다.
- block
    - 블록 I/O 계층은 블록 장치 (하드 디스크, DVD, 플로피 디스크 등 저장 장치) 및 해당 요청을 관리하기  위한 코드를 포함합니다.
- certs
    - 커널이 서명 된 모듈을 로드 할 수 있도록 모듈 서명을 활성화하는 인증서 및 서명 파일
- crypto
    - 암호화 API. 암호화 및 압축 작업을 처리하는 암호화 암호를 포함
- drivers
    - 하드웨어 장치 드라이버. 하드웨어를 지원하기위한 장치 드라이버 코드가 들어 있습니다.
    - 이 디렉토리에는 비디오, 블루투스 등과 같은 각 하드웨어 (하위 하드웨어 지원)와 같은 하위 디렉토리가 있습니다.
- fs (file system)
    - 가상 파일 시스템 및 추가 파일 시스템에 대한 코드
    - 이 디렉토리에는 파일 시스템을 지원하고 읽고 쓰는 코드가 들어 있습니다.
- include
    - 커널 헤더. 이 디렉토리에는 코드를 컴파일하는 함수와 같은 커널 파일의 C 헤더가 있습니다.
- init
    - 커널 부팅. 커널 초기화와 관련된 소스 코드를 포함합니다.
    - 소스 코드는 /init 디렉토리 내의 mainc.c라는 파일에 저장됩니다. 코드는 커널과 일부 초기 프로세스를 초기화합니다.
- ipc
    - 신호 및 파이프와 같은 프로세스 간 통신
- kernel
    - 스케줄러 신호 처리 코드 등과 같은 핵심 서브 시스템
- lib
    - 라이브러리 루틴 공통 문자열 조작, 하드웨어 종속 조작, 디버깅 루틴 및 명령 행구문 분석 코드
- mm (memory management)
    - 메모리 관리 및 가상 메모리. 커널은 하드웨어와 가상 메모리(스왑)를 모두 관리합니다.
    - 이 디렉토리는 메모리 관리를 위한 코드를 저장합니다.
- net
    - 네트워크 스택. IP, TCP, UDP 등과 같은 통신 프로토콜과 관련된 코드를 포함합니다.
- samples
    - 샘플 코드 및 구성 파일
- scripts
    - 커널을 빌드하는 스크립트
- security
    - LSM (Linux Security Module)은 보안 정책이 모듈 제어에 액세스 할 수 있도록 하는 프레임 워크
- sound
    - 사운드 하위 시스템에는 ALSA와 같은 사운드와 관련된 사운드 드라이버 및 코드가 있습니다.
- tools
    - ACPI, cgroup, USB 테스트 도구, vhost 테스트 모듈, GPIO, IIO 및 spi 도구와 같은 압축 커널 개발 도구, 기타 에너지 정책 도구
- usr
    - 파일 시스템을 루트화하고 커널 메모리 캐시에서 초기화하는 initramfs
- virt (vitual)
    - 가상화
    - 이 디렉토리에는 하이퍼바이저 용 KVM (Kernel Virtual Machine) 모듈 포함
    

---

### 리눅스 커널 컴파일

**리눅스 커널 생성 과정 3단계**

1. 커널 구성 (Kernel Configuration)
    
    커널 구성은 새로 리눅스 커널 컴파일 시 사용할 환경 변수 등을 설정하는 과정이다. 하드웨어 특성, 커널 특성 등 설정 정보를 지정하는 과정이다. make config, make menuconfig, make xconfig 등의 방법이 있다. 커널 구성 단계에서 사용자가 선택한 사항은 .config 이라는 파일에 저장되며 이후 커널 컴파일 단계에서 사용된다.
    
2. 커널 컴파일 (Kernel Compile)
    
    커널 소스 파일을 이용해 실행 가능한 커널 이미지를 만드는 과정으로 make bzImage, make zImage 등의 명령으로 생성할 수 있다. (2.6버전 이후 make 명령으로 생성 가능) 커널 컴파일이 완료되면 시스템 아키텍처에 따라 kernel/arch/x86/boot/ 디렉토리 이하에 커널 이미지가 생성된다.
    
3. 커널 인스톨 (Kernel Installation)
    
    생성된 커널 이미지로 시스템이 부팅될 수 있도록 만드는 과정이다. 생성된 이미지를 파일시스템으로 복사, 커널 모듈 인스톨, 부트로더(grub) 수정 등의 과정으로 이루어진다.
    

---

### 태스크

유저 프로세스는 커널 내부에서는 task_struct라는 구조체로 관리된다. task_struct 구조체 하나가 프로세스 하나를 모두 관리한다. 그리고 지금 시점에 동작해야할 태스크를 할당할 때 스케쥴러 정책에 의해 task_struct 구조체 정보를 이용하여 할 일을 수행한다. 

![image](https://user-images.githubusercontent.com/61526722/198813484-57c76f40-6fb5-4f85-93bf-cc65d8aa4111.png)

task_struct 자료구조 (/include/linux/sched.h - struct task_struct)에 존재한다. 

---

### 메모리

요즘의 CPU는 다수의 CPU가 동일한 메모리를 공유할 수 있는 SMP (Symmetric Multiprocessing) 다중처리 구조를 가진다. 

**메모리 접근 방식**

- UMA (Uniform Memory Access) : 균일 기억장치 접근
    - 모든 프로세서들이 상호간에 연결되어 하나의 메모리를 공유하는 기술
    - 통로가 하나 밖에 없어서 병목 현상 유발
- NUMA (Non-Uniform Memory Access): 불균일 기억장치 접근
    - 효율성, 병목 현상 해결
    - 메모리에 접근하는 시간이 프로세서와 메모리의 상대적 위치에 따라서 달라짐
    - 메모리와 CPU를 작게 클러스터링 하여 CPU는 가까운 메모리에 접근 → 클러스터링 개념

![image](https://user-images.githubusercontent.com/61526722/198813491-d6bbe4d3-f734-4a53-9ece-976d2fbd6c09.png)

물리 메모리 관리

- 노드: 다수의 메모리 집합, NUMA 구조에서는 다수의 메모리 노드가 존재
- zone: 메모리 내의 범위를 나타내는 노드 내의 블록
    - ZONE_DMA/ZONE_DMA32 (0 ~ 16M) : ISA 버스 기반 디바이스에서 사용
    - ZONE_NORMAL (16 ~ 896M) : 커널의 가상주소공간과 1:1 연결 (가상 메모리 공간은 물리 메모리 공간 보다 훨씬 크기 때문에 1:1로 매핑할 수 없음 )
    - ZONE_HIGHMEM (896 ~ End) : 필요할 때 동적으로 연결
- page: 물리 메모리의 최소 단위를 페이지 프레임이라고 함

---

### 파일 시스템

파일시스템은 컴퓨터에서 파일이나 자료를 쉽게 발견 및 접근할 수 있도록 보관 또는 조직하는 체제를 말한다. 

파일시스템은 하드디스크나 SSD와 같은 전체 디스크 저장 공간을 디스크 블록 단위(ex. 4KB) 단위로 나누어 관리한다. 디스크 블록 사이즈가 크면 한번에 읽어 들이거나 쓰는 단위가 커지므로, 실제 물리적인 I/O 접근 횟수가 줄어들어 I/O 병목현상을 줄일 수 있다. 속도가 빠르지만 단점으로 외부단편화 현상으로 낭비되는 공간이 많아진다. 파일시스템은 디스크 저장 공간을 논리적인 디스크 블록들의 집합으로 본다. 디스크 블록은 0, 1, 2 등의 논리적인 번호를 가진다. 이 논리적인 디스크 블록의 번호를 통해 디스크 저장 공간에 접근한다.

![image](https://user-images.githubusercontent.com/61526722/198813495-d6464f3d-d990-4d7c-826b-c2941529c9a5.png)

---

### 인터럽트

마이크로프로세서에서 인터럽트(interrupt)란 마이크로프로세서(CPU)가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우에 마이크로프로세서에게 알려 처리할 수 있도록 하는 것을 말한다.

키보드가 눌려지거나, 네트워크 인터페이스를 통해 패킷이 도착하거나 하는 경우 인터럽트가 발생한다. 이때 작업을 처리하는 함수를 인터럽트 핸들러(interrupt handler)라고 부른다.

- 외부 인터럽트
    - 현재 태스크과 상관없는 외부 주변장치에서 발생된 비동기적인 하드웨어 인터럽트
    - 키보드, 네트워크 인터페이스 등
- 트랩
    - 현재 수행중인 태스크와 관련 있는 동기적인 인터럽트, 예외처리
    - devide by zero, segmentation fault, page fault, system call 등
