---
layout: post
title: Shortest Path
date: 2021-07-01
category: Algorithm
use_math: true
---

최단 경로 알고리즘은 가장 짧은 경로를 찾는 알고리즘으로 길 찾기 문제라고도 불린다. 최단 경로 문제는 보통 그래프를 이용해 해결한다. 코딩테스트에서는 최단 경로를 출력하는 문제보다는 단순히 최단 거리를 출력하는 문제가 많다. 최단 거리 알고리즘에는 다익스트라 최단 경로 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘 등이 있다. 그리고 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 최단 경로 알고리즘에 그대로 적용된다. 

최단 경로 알고리즘은 한 지점에서 다른 한 지점까지의 최단 경로, 한 지점에서 다른 모든 지점까지의 최단 경로, 모든 지검에서 다른 모든 지점까지의 최단 경로를 구하는 문제로 나뉜다. 각 상황에 맞는 알고리즘이 이미 정립되어 있으므로 각각을 살펴보도록 한다.

---

### 1. 다익스트라 최단 경로 알고리즘 (Dijkstra)

다익스트라는 그래프에서 여러 개의 노드가 있을 때, <mark>특정한 노드에서 다른 모든 노드로 가는 최단 경로를 구해주는 알고리즘</mark>이며, <mark>음의 간선이 없을 때 </mark>정상적으로 작동한다. 다익스트라 알고리즘은 기본적으로 <mark>그리디 알고리즘</mark>으로 분류된다. 매번 비용이 가장 적은 노드를 선택하는 과정을 반복하기 때문이다.


> ① 출발 노드를 설정한다.
>
> ② 최단 거리를 저장하는 리스트(최단 거리 테이블)를 만들어 초기화한다.
>
> ③ 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
>
> ④ 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
>
> ⑤ 모든 노드가 방문처리 될 때까지 3,4번을 반복한다.

말로는 이해가 잘 가지 않을 것이다. 예시를 통해 다익스트라의 동작 원리를 살펴보자. 다음 그래프에서 1번 노드에서 다른 모든 노드로 가는 최단 경로를 구한다고 하자. 초기상태에서는 다른 모든 노드로 가는 최단 거리를 무한으로 초기화한다.

![image](https://user-images.githubusercontent.com/61526722/124107642-693a8f00-daa0-11eb-810a-6e2971185f6c.png)


다음으로 1번 노드를 거쳐 다른 노드로 가는 비용을 계산한다. 1 ➔ 2 (거리=2), 1 ➔ 3 (거리=5), 1 ➔ 4 (거리=1) 이 된다. 



다음으로 아직 방문하지 않은 노드들 중에서 최단 거리가 가장 작은 4번 노드를 선택한다. 이 4번 노드를 거쳐서 갈 수 있는 노드는 3번과 5번으로 1 ➔ 4 ➔ 3 (거리=4), 1 ➔ 4 ➔ 5 (거리=2)이다. 이는 현재 최단 거리 테이블에 있는 값보다 작으므로 3번과 5번 노드의 최단 거리 값을 각각 4, 2로 갱신한다.



다음으로 아직 방문하지 않은 노드들 중에서 최단 거리가 가장 작은 2번, 5번 중 번호가 작은 노드인 2번을 선택한다. 이 2번 노드를 거쳐서 갈 수 있는 노드는 3번과 4번으로 1 ➔ 2 ➔ 3 (거리=5), 1 ➔ 2 ➔ 4 (거리=4)이다. 하지만 이미 현재 최단거리 테이블에 있는 값이 작으므로 갱신되지 않는다.


다음으로 아직 방문하지 않은 노드들 중에서 최단 거리가 가장 작은 5번을 선택한다. 5번 노드를 거쳐서 갈 수 있는 노드는 3번과 6번으로, 1 ➔ 5 ➔ 3 (거리=3), 1 ➔ 5 ➔ 6 (거리=4)이다. 여기서 1번과 5번을 연결하는 간선은 없지만 편의상 그렇게 표현하고 최단거리 테이블에 있는 1 ➔ 5 (거리=2)를 더해준다고 생각하면 된다. 이번에는 3번과 6번의 최단 거리가 모두 갱신된다. 



다음으로 아직 방문하지 않은 노드들 중에서 최단 거리가 가장 작은 3번을 선택한다. 3번 노드를 거쳐서 갈 수 있는 노드는 2번과 6번으로, 1 ➔ 3 ➔ 2(거리=6), 1 ➔ 3 ➔ 6 (거리=8)이다. 하지만 이미 현재 최단거리 테이블에 있는 값이 작으므로 갱신되지 않는다.


다음으로 마지막 남은 6번 노드를 선택한다. 




이처럼 다익스트라는 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복하는데, 한 번 선택되고 방문된 노드는 최단 거리가 감소하지 않는다. 즉, 다익스트라는 한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다. 

---

### 2. Dijkstra with Python

다익스트라 알고리즘은 <mark>힙 자료구조를 사용하여 O(ElogV) 시간</mark>으로 구현할 수 있다. 여기서 V는 정점의 개수, E는 간선의 개수이다. 
힙은 우선순위 큐를 구현하기 위해 사용하는 자료구조 중 하나라고 했다. [참고](https://yeji-shin.github.io/datastructure/2021/07/01/5.-Priority-Queue.html) 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제한다. 따라서 최단 거리가 가장 짧은 노드를 선택하는 과정에서 최소 힙 자료구조를 사용하면 된다.

파이썬의 heapq 라이브러리는 원소로 튜플을 입력받으면 첫 번째 원소를 기준으로 우선순위 큐를 구성한다. 따라서 (최단 거리, 노드 번호) 순서대로 튜플 데이터를 구생해 우선순위 큐에 넣으면 된다. heapq는 데이터의 개수가 N개일 때, 하나의 데이터를 삽입 및 삭제할 때의 시간 복잡도는 O(logN)이다. 따라서 정점의 개수 V개, 간선의 개수 E개 일때 다익스트라는 O(ElogV)의 시간 복잡도를 가진다. 

```python

```











