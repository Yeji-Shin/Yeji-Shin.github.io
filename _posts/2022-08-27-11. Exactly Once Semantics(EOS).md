---
layout: post
title: 11. Exactly Once Semantics(EOS)
date: 2022-08-27
category: Kafka
use_math: true
---


## Delivery Semantics

Producer가 메세지를 전송하는 방식은 여러가지가 있다. 

- At-Most-Once Semantics(최대한번)
  - 확인 시간이 초과되거나 오류가 반환될때 Producer가 재시도 하지 않으면, 메시지가 Kafka Topic에 기록되지 않아 Consumer 에게 전달되지 않을 수 있음
  - 중복 가능성을 피하기 위해 때때로 메시지가 전달되지 않을 수 있음을 허용
- At-Least-Once Semantics(최소한번)
  - Producer가 Kafka Broker로부터 ack를 수신하고 acks=all 이면 메시지가 Kafka Topic에 최소 한번 작성되었음을 의미함
  - 그러나 ack가 시간 초과되거나 오류를 수신하면 메시지가 Kafka Topic에 기록되지 않았다고 가정하 고메시지 전송을 다시 시도할 수 있음
  - Broker가 ack를 보내기 직전에 실패했지만 메시지가 Kafka Topic에 성공적으로 기록된 후에 이 재시도를 수행하면 메시지가 두 번 기록되어 최종 Consumer에게 두번 이상 전달 되어 중복 작업과 같은 잘못된 결과로 이어질 수 있음
- Exactly-Once Semantics(정확히한번)
  - Producer가 메시지 전송을 다시 시도하더라도 메시지가 최종 Consumer에게 정확히 한 번 전달됨
  - 메시징 시스템 자체와 메시지를 생성하고 소비하는 애플리케이션 간의 협력이 반드시 필요함
  - 예를들어, 메시지를 성공적으로 사용한 후 Kafka Consumer를 이전 Offset으로 되감으면 해당 Offset에서 최신 Offset까지 모든 메시지를 다시 수신하게 됨

---

## Exactly-Once Semantics (EOS)

EOS는 중복 메세지로 인한 중복 처리를 방지하기 위해 사용된다. 데이터가 정확히한번 처리되도록 보장해야 하는 실시간 미션 크리티컬 스트리밍 Application이다. EOS를 하기 위해서는 두 가지 옵션을 사용해야 한다. 

- Idempotent Producer
  - 클라이언트(Idempotent Producer)에서 생성되는 중복 메시지 방지
  - Producer의 파라미터중 enable.idempotence 를 true 로 설정해야 함
  - Producer가 Retry(재시도)를 하더라도, 메시지 중복을 방지함
- Transaction
  -  하나의 트랜잭션 내의 모든 메시지가 모두 Write 되던지, 전혀 Write 되지 않게 하던지 (Atomic Message) 설정
  -  각 Producer에 고유한 transactional.id를 설정
  -  Producer를 Transaction API를 사용하여 개발되어 있어야 함
  -  Consumer에서 isolation.level을 read_committed로 설정 (transaction 은 commit 하기 전에 들어와 있는 메세지를 consumer 가 가져가서 쓰면 안되기 때문)  

EOS는 java client 에서만 지원한다. 

- Transaction Coordinator 사용
  -  특별한Transaction Log를관리하는Broker Thread
  - 일련의ID 번호(Producer ID, Sequence Number, Transaction ID)를할당하고 클라이언트가이정보를메시지Header에포함하여메시지를고유하게식별
  - Sequence Number는Broker가중복된메시지를skip할수있게함

---

## Idempotent Producer 메시지 전송 프로세스

메세지는 sequence number와 고유한 producer ID 를 가지고 전송이 된다. 이렇게 보내진 데이터는 broker의 메모리에 map 정보가 저장된다. 이 map은 `*.snapshot` 파일에 일정 주기로 저장된다. 

![image](https://user-images.githubusercontent.com/61526722/187023380-88e8570e-5748-4f3f-86af-fbeadf3df64b.png)

![image](https://user-images.githubusercontent.com/61526722/187023383-e10d2476-3863-4189-8671-3909ebbab369.png)


만약에 broker가 ack를 보내지 못한 경우에는, producer가 ack를 받지 못했기 때문에 동인한 메세지에 대한 재시도를 수행한다. 이때 enable.idempotence=true로 설정하지 않았다면, broker는 메세지를 중복으로 받지 못한다. 그렇기 떄문에 broker는 메세지를 받지 못하고 duplicate 에러를 보낸다. 

![image](https://user-images.githubusercontent.com/61526722/187023438-c1abaa1c-94a2-4ceb-a76b-b7ff8a30b784.png)


![image](https://user-images.githubusercontent.com/61526722/187023443-c35ab819-625b-40d1-93b6-44c5b0374d56.png)


![image](https://user-images.githubusercontent.com/61526722/187023451-bb1d59ab-5c23-4f56-b645-fa61449473d1.png)

---

## Transaction

Transaction을 구현하기 위해서 몇 가지 새로운 개념들이 필요하다. 

- Transaction Coordinator
  - 각 producer에는 transaction coordinator가 할당되어 PID 할당 및 transaction 를 관리하는 데 필요한 모든 로직을 수행한다. 
- Transaction log
  - internal kafka topic으로 consumer offset topic과 유사하게 모든 transaction의 영구적인 record를 저장하는 transaction coordinator의 상태 저장소이다. 
- Transanctionalid
  - producer를 식별하기 위해 사용되는 고유 번호 
  - 동일한 transactionid를 가진 서로 다른 producer 들은 이전에 만들어진 transaction을 다시 시작하거나 중단 가능 

## Transaction parameters 

![image](https://user-images.githubusercontent.com/61526722/187023675-be3fa370-5ba0-4c68-9517-7a7585974abb.png)

![image](https://user-images.githubusercontent.com/61526722/187023684-8a875e8a-c680-4b52-8dd9-1f19587ec068.png)

![image](https://user-images.githubusercontent.com/61526722/187023690-e51f1e47-55bf-4184-95f6-6306a0a70248.png)


## Transaction 처리 프로세스





