---
layout: post
title: Class(2) - 여러가지 속성
date: 2022-08-11
category: Python
use_math: true
---

## __str__()

`__str__()`은 객체를 출력할 때 호출되는 메서드이다. 
다시말해 객체를 사용자가 이해할 수 있는 문자열로 반환하는 내장 함수로 `__str__()` 함수를 오버라이딩해서 사용할 수 있다. 

`__str__()`을 본적이 없더라도 str() 함수는 써봤을 것이다. 사실 str()은 내장 함수가 아니라 파이썬 기본 내장 클래스이다. 
예를 들어 str(3)을 실행하는 것은 str 내장 함수를 실행하는 것이 아니라 내장 str 클래스의 생성자 메소드를 실행하고 그 인자로 3을 주는 것이다. 

이처럼 파이썬에는 자료형에 대한 연산을 정의하는 메소드들이 있다. 그 메소드들은 메소드의 이름 앞위에 `__`를 쓰고 있다. 
또 하나 예를 들어보면 다음과 같다. 

```
>>> 3 + 5
8
>>> (3).__add__(5)
8
>>> 
```

3 + 5 는 내부적으로 `(3).__add__(5)`를 수행한다. 
int 클래스에서는 ‘+’ 연산을 처리하는 `__add__`메소드를 정의하고 있고, ‘+’ 기호가 들어왔을 때 이 메소드가 실행되는 구조인 것이다.
다시 말해 어떤 값에 대해 +, -, *=, >> 등의 연산자를 취하는 것은 내부적으로 `__add__`,  `__sub__`, `__imul__`, `__rshift__` 메소드를 실행하는 것과 동일하다. 


```python
class Monster:
    def __init__(self, health, attack, speed):
        self.health = health
        self.attack = attack
        self.speed = speed

    def __str__(self):
        return f'체력: {self.health}, 공격력: {self.attack}, 속도: {self.speed}'

goblin = Monster(800, 120, 300)
goblin.decreae_health(100)
goblin.get_health()

wolf = Monster(400, 250, 150)
print(wolf)

결과
>>> print(wolf)
체력: 400, 공격력: 250, 속도: 150
```

객체를 생성하고 print(객체)로 객체 자체를 print 해보면, 자동으로 `__str__()` 메서드가 호출되어 f'체력: {self.health}, 공격력: {self.attack}, 속도: {self.speed}'메세지를 반환해준다. 


---

# 여러가지 속성 

- 인스턴스 속성
- 클래스 속성
- 비공개 속성


## 인스턴스 속성 (instance attribute)

인스턴스 속성은 객체마다 다르게 가지는 속성이다. 다시말해 self.name = name 과 같이 self.변수이름 = 변수이름 부분이 인스턴스 속성이다.

- 클래스 안에서 인스턴스 속성 사용: self.속성명
- 클래스 밖에서 인스턴스 속성 사용: 객체명.속성명

```python
class Unit:
    def __init__(self, name, hp, shield, demage):
        self.name = name
        self.hp = hp
        self.shield = shield
        self.demage = demage

probe = Unit("프로브", 20, 20, 5)
zealot = Unit("질럿", 100, 60, 16)
dragoon = Unit("드라군", 100, 80, 20)
```

```
>>> probe.name
'프로브'
```

위의 예제에서 probe는 probe 만의 name, hp, sheild, damage를 가지고 있는 것이고 zealot은 zealot만의 name, hp, sheild, damage를 가지고 있다. 

## 클래스 속성 (class attribute)

클래스 속성은 모든 객체가 공유하는 속성이다. 클래스 속성은 self를 사용하지 않는다. 

- 클래스 안에서 클래스 속성 사용: 객체명.속성명
- 클래스 밖에서 클래스 속성 사용: 객체명.속성명

```
class Unit:
    count = 0
    def __init__(self, name, hp, shield, demage):
        self.name = name
        self.hp = hp
        self.shield = shield
        self.demage = demage
        Unit.count += 1

probe = Unit("프로브", 20, 20, 5)
zealot = Unit("질럿", 100, 60, 16)
dragoon = Unit("드라군", 100, 80, 20)

Unit.count

결과
3
```
위 예제에서 count 값은 클래스 속성이다. 


## 비공개 속성 (private attribute)

비공개 속성은 클래스 안에서만 접근 가능한 속성이다. 클래스 밖에서 특정 속성에 접근하지 못하게 하고 싶을 때 `__속성명` 으로 사용하면 된다. 
비공개 속성은 다른 값으로 변경이 불가능하다. 


- 클래스 안에서 비공개 속성 사용: `self.__속성명`
- 클래스 밖에서 비공개 속성 사용: 불가능 (name mangling 으로 가능)

```python
class Unit:
    def __init__(self, name, hp, shield, demage):
        self.name = name
        self.__hp = hp
        self.shield = shield
        self.demage = demage

    def __str__(self):
        return f'[{self.name}] 체력: {self.__hp}, 방어막: {self.shield}, 공격력: {self.demage}'

probe = Unit("프로브", 20, 20, 5)
zealot = Unit("질럿", 100, 60, 16)
dragoon = Unit("드라군", 100, 80, 20)

zealot.__hp

결과
AttributeError: 'Unit' object has no attribute '__hp'
```

사실 비공개 속성은 접근 자체가 아예 불가능한 것은 아니고 name mangling 이라는 이름을 바꾸는 기술을 사용해 접근이 어렵게 만들어놓은 것이다. 

```
>>> print(probe)
[프로브] 체력: 20, 방어막: 20, 공격력: 5
>>> probe.__hp = 9999
>>> print(probe)
[프로브] 체력: 20, 방어막: 20, 공격력: 5
```

```
>>> print(zealot)
[질럿] 체력: 100, 방어막: 60, 공격력: 16
>>> zealot._Unit__hp = 9999
>>> print(zealot)
[질럿] 체력: 9999, 방어막: 60, 공격력: 16
```

