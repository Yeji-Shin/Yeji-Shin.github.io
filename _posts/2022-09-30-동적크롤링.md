---
layout: post
title: 동적 크롤링
date: 2022-09-30
category: Web
use_math: true
---


### 정적 웹사이트 vs 동적 웹사이트

정적 웹사이트는 움직임이 없는 고정된 웹사이트이고, 동적 웹사이트는 움직임이 많은 다이나믹한 웹사이트이다. 여기서 움직임이란 HTML node의 움직임으로, 웹사이트가 처음 로딩된 후에 사용자가 어떤 행동을 하여 웹사이트에 변화가 있는 경우 움직임이 있다고 표현한다. 

정적 웹사이트는 브라우저에 렌더링 할 때 처음에 HTML이 주는 그대로 화면에 그려내면 된다. 즉, HTML과 CSS를 그리는데, 처음에 웹 서버와 통신할 때 받아와서 렌더링하고 그 후에는 웹 서버와 통신을 하지 않는다. 동적 웹사이트는 JS 를 그려낸다고 보면 된다. 사용자가 특정 행동을 하면 웹서버에서 새로운 데이터를 새로 가져와서 다시 렌더링을 하는 것이다. 따라서 웹 서버와의 통신이 잦다. 

---

### 셀레니움

셀레니움은 브라우저 테스팅 툴 또는 브라우저 원격 조종 툴로 동적 크롤링에 많이 사용된다. 페이스북에서 무한 스크롤 기능이 잘 작동하는지 테스트 해야할 떄 사람이 계속 스크롤을 내리면서 작동이 잘 되는지 테스트를 하는것이 아니라 컴퓨터한테 자동화 테스트를 시켜서 인력을 최소화한다. 이 자동화 테스트를 가능하게 하는 툴이 셀레니움이다. 셀레니움은 브라우저와 TCP 통신을 한다.

selenium 패키지를 다운 받는다.

```bash
pip install selenium
```

다음으로 자신의 크롬 버전을 확인하여 그에 맞는 크롬 드라이버를 https://chromedriver.chromium.org/downloads에서 다운 받은 후에 실행시킬 파이썬 파일과 같은 경로에 넣어준다. 

```python
from selenium import webdriver
import time

# 셀레니움으로 크롬 조작하기 (naver.com 10초동안 열었다가 닫기)
# 셀레니움은 크롬을 디버그 모드로 켜서 조작함
browser = webdriver.Chrome('./chromedriver.exe')
browser.get('http://naver.com')
time.sleep(10)
browser.close()
```

도커로 셀레니움을 실행하려면 아래와 같이 하면 된다. 

```bash
$ docker run -p 4444:4444 selenium/standalone-chrome
```

도커로 실행하면 크롬 드라이버가 따로 없어도 실행가능하다. 

```python
from selenium import webdriver
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities

browser = webdriver.Remote("http://127.0.0.1:4444/wd/hub", DesiredCapabilities.CHROME) # 셀레니움에게 크롬을 사용할 것이라고 알려줌 
browser.get("http://naver.com")
print(browser.title)
browser.close()
```

---

### 페이지 이동

get으로 페이지를 이동할 수 있다. 

```python
from selenium import webdriver
import time

'''
셀레니움이 디버그 모드로 크롬을 켤 때 우리가 사용하던 extension들을 같이 켜주지 않음 
-> options.add_encoded_extension()으로 추가해줘야 함
'''
options = webdriver.ChromeOptions()
options.add_argument('window-size=1000,1000')  # 1000x1000 해상도로 크롬 창을 실행
options.add_argument('no-sandbox')  # 크롬의 각 탭은 별개의 프로그램(보안 격리를 위함)인데 no-sandbox 옵션을 주면 자유롭게 탭을 이동하면서 크롤링이 가능함
# options.add_argument('headless') # 크롬창을 보이지 않게함 (CPU 사용량 최소화)

chrome = webdriver.Chrome('./chromedriver.exe', options=options)
chrome.get('https://naver.com') # 해당 페이지로 이동 (requests 의 get과 다름)
chrome.get('https://shopping.naver.com')
chrome.back()  # 전 페이지로 이동
chrome.forward()  # 다음 페이지로 이동
time.sleep(3)
chrome.close()
```

### 페이지 로딩

만약에 페이지가 로딩이 아직 완료되지 않은 상태에서 검색을 실행하면 에러가 난다. 셀레니움은 기본적으로 페이지 로딩을 기다려주는 JS 가 실행되는 그 쯤까지만 기다려준다. 아래 그림은 웹 페이지가 로딩되는 순서를 그림으로 그린 것인데, 셀레니움은 HTML과 CSS와 같이 로드되는 JS까지는 기다려주지만, HTML과 CSS 로드된 후에 로드되는 JS는 기다려주지 않는다.  HTML과 CSS 로드된 후에 로드되는 JS를 onload라고 하는데 onload들이 엮여 있는것을 onload chaining이라고 한다. 

![image](https://user-images.githubusercontent.com/61526722/193249845-7634a33a-0d5a-4b00-9452-db7b92f6baf2.png)

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

options = webdriver.ChromeOptions()
options.add_argument('window-size=1000,1000')  
options.add_argument('no-sandbox')  

chrome = webdriver.Chrome('./chromedriver.exe', options=options)
chrome.get('https://shopping.naver.com')

# 1. time.sleep(): 파이썬 프로그램을 멈춤
time.sleep(10)

# 2. implicitly_wait(): 크롬 드라이버를 멈춤
chrome.implicitly_wait(10)

# 3. 우리가 원하는 element가 표시될 때까지 멈춤
# input[name=query] css selector가 나타날때까지 최대 10초 기다리기
WebDriverWait(chrome, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "input[name=query]")))

chrome.close()
```

### element 찾기

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

options = webdriver.ChromeOptions()
options.add_argument('window-size=1000,1000')  
options.add_argument('no-sandbox')  

chrome = webdriver.Chrome('./chromedriver.exe', options=options)
chrome.get('https://shopping.naver.com')

# css selector 기반으로 element 찾기
wait = WebDriverWait(chrome, 10)
el = WebDriverWait(chrome, 10).until(EC.presence_of_element_located((By.CSS_SELECTOR, "input[name=query]")))
print(el)

chrome.close()
```


### element 클릭

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

options = webdriver.ChromeOptions()
options.add_argument('window-size=1000,1000')  
options.add_argument('no-sandbox')  

chrome = webdriver.Chrome('./chromedriver.exe', options=options)
chrome.get('https://shopping.naver.com')

wait = WebDriverWait(chrome, 10)
def find(wait, css_selector):
    return wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, css_selector)))

# 검색어 입력
search = find(wait, "input[name=query]")
search.send_keys('아이폰')
time.sleep(3)

# 검색 버튼 클릭
button = find (wait, 'a.co_srh_btn')
button.click()
time.sleep(3)

# 검색어 입력 및 검색 실행
search.send_keys('아이폰\n') 

chrome.close()
```

### 네이버 쇼핑 구매


![image](https://user-images.githubusercontent.com/61526722/193393647-a4d310c4-a41f-4e90-9a26-d8fe7b2a7f7c.png)

![image](https://user-images.githubusercontent.com/61526722/193393623-df2c943c-2805-40aa-89f5-84b0d50b7bfc.png)

![image](https://user-images.githubusercontent.com/61526722/193393880-a6fb6ef6-9968-4911-9bd2-136146468f49.png)

![image](https://user-images.githubusercontent.com/61526722/193394210-faf90627-6e93-4461-9c6c-9955c3bd6565.png)

![image](https://user-images.githubusercontent.com/61526722/193394381-892cb328-c8ed-43cf-8a79-fd37d481ac88.png)

![image](https://user-images.githubusercontent.com/61526722/193394867-a01ac4aa-9b98-44f1-a8ef-7e2c833a5680.png)

![image](https://user-images.githubusercontent.com/61526722/193396056-28708613-67cc-4c23-80dc-f598f75f29c1.png)

![image](https://user-images.githubusercontent.com/61526722/193396421-b730beb2-dbc5-4112-8350-b330c033fef8.png)

![image](https://user-images.githubusercontent.com/61526722/193396431-29165ae8-0b27-4773-a615-03b9e788b98d.png)

전체코드

```python
import os
from re import T
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
import time
import os
import pyperclip

options = webdriver.ChromeOptions()
options.add_experimental_option('excludeSwitches', ['enable-logging'])

chrome = webdriver.Chrome('./chromedriver.exe', options=options)
wait = WebDriverWait(chrome, 10)
short_wait = WebDriverWait(chrome, 3)

chrome.get('https://shopping.naver.com')

'''
버튼이 생길때 까지 기다리기 (버튼이 생긴다고 클릭할 수 있는 상태가 아닐 수도 있음)
login_button = wait.until(EC.presence_of_all_elements_located(By.CSS_SELECTOR, 'a#gnb_login_button')) # a태그의 gnb_login_button
'''
# 버튼이 생기고 클릭할 수 있는 상태가 될때까지 기다리기
login_button = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'a#gnb_login_button'))) # a태그의 gnb_login_button
login_button.click() # 로그인 버튼 클릭

input_id = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'input#id')))
input_pw = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'input#pw')))

# pyperclip으로 자동로그인 방지 해제
pyperclip.copy('본인아이디') # 아이디 클립보드에 복사
input_id.send_keys(Keys.CONTROL, 'v') # 붙여넣기
pyperclip.copy('본인비밀번호')
input_pw.send_keys(Keys.CONTROL, 'v') 
input_pw.send_keys('\n') # 엔터

'''
input_id.send_keys('본인아이디')
input_pw.send_keys('본인비밀번호')
input_pw.send_keys('\n')
'''

# 로그인 되었는지 확인 (로그아웃 버튼이 있으면 로그인이 성공한 것임)
short_wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, 'a#gnb_logout_button')))

# 상품 검색
search = wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, 'input[class=_searchInput_search_text_3CUDs]')))
search.send_keys('아이폰 케이스')
time.sleep(1)
search.send_keys('\n')

# 스크롤 내리기 (JS를 셀레니움이 실행하게 만듦)
# chrome.execute_script('window.scrollBy(0, document.body.scrollHeight)') # x로는 움직이지 않고, y로 최대로 이동
for i in range(8):
    chrome.execute_script("window.scrollBy(0, "+ str((i+1)*1000) +")")
    time.sleep(1) # 스크롤 내리고 로딩되는 것 잠깐 기다리기

# 상품 리스트 (div 태그인데 class 이름이 basicList_info_area__로 시작하는 애들 가져오기)
# 추후에 광고를 제거하기 위해 sibling node 참조를 위해 검색을 div로 함 (셀레니움은 parent로 가는것이 한정적이라 공통분모를 찾아야 함)
wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "div[class^=basicList_info_area__]")))
items = chrome.find_elements(By.CSS_SELECTOR, "div[class^=basicList_info_area__") # 모든 div태그 가져오기
for item in items:
    # 광고 거르기
    try:
        item.find_element(By.CSS_SELECTOR, "button[class^=ad_]")
        continue
    except:
        pass
    print(item.find_element(By.CSS_SELECTOR, 'a[class^=basicList_link__').text)

# 상품 클릭 (첫번째 상품 구매한다고 가정)
wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "a[class^=basicList_link__"))).click()
time.sleep(2) # 새로운 탭이 열릴 시간을 줌
print(chrome.title)  # 현재 창의 제목 (아이폰 케이스 : 네이버 쇼핑) -> 꺼진 탭의 제목

# 새로운 탭 연결
print(chrome.window_handles) # 창의 이름 출력 -> ['CDwindow-D6A7AA055EE2E7636053E2A9F78391CE', 'CDwindow-1C5BBA469099DE8E361BB1CF8BD83952']
chrome.switch_to.window(chrome.window_handles[1]) # 탭 연결 전환
print(chrome.title) # 새로운 탭 이름 (독보적인 설계, 정교한 디테일. 아이폰 14 x UAG의 완벽한 만남 : UAGKOREA)

# 옵션 선택
wait.until(EC.visibility_of_element_located((By.CSS_SELECTOR, "a[aria-haspopup='listbox']")))
ops = chrome.find_elements(By.CSS_SELECTOR, "a[aria-haspopup='listbox']")

ops[0].click() # 첫번째 옵션 클릭
time.sleep(1)
chrome.find_element(By.CSS_SELECTOR, "ul[role=listbox] li:nth-child(1) a[role=option]").click() # ul 태그의 자식 노드중에 첫번쨰 li 태그에서 a태그 중에 role이 option인것 선택

ops[1].click() # 두번째 옵션 클릭
time.sleep(1)
chrome.find_element(By.CSS_SELECTOR, "ul[role=listbox] li:nth-child(1) a[role=option]").click()

# 구매하기 버튼 누르기
chrome.find_element(By.CSS_SELECTOR, "div[class*='N=a:pcs.buy'] a").click()

time.sleep(5)

chrome.close() # 크롬과 연결되어 있는 탭을 끄기
chrome.quit() # 연결되어 있지 않은 탭도 끄기
```
