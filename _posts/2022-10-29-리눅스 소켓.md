---
layout: post
title: 리눅스 소켓
date: 2022-10-29
category: Linux
---

### TCP/IP

인터넷 프로토콜 제품군(Internet Protocol Suite) 은 인터넷 및 유사한 컴퓨터 네트워크에서 사용되는 개념적 모델 및 통신 프로토콜 집합이다. 제품군의 기본 프로토콜은 TCP (Transmission Control Protocol) 및 IP (Internet Protocol)이기 때문에 일반적으로 TCP/IP 라고 한다. 

IP는 패킷 통신 방식의 인터넷 프로토콜이고, TCP는 IP위에서 동작하는 전송 조절 프로토콜이다. TCP/IP로 통신한다는 것은 송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고 그 데이터가 제대로 갔는지, 너무 빠르지는 않았는지, 제대로 받았다고 연락은 오는지에 대한 것이다. 이러한 정보는 TCP 헤더에 담겨있다. TCP는 IP정보와 port를 이용하여 연결하는데, 한쪽 단말에 도착한 데이터가 어느 입구(port)로 들어가야 하는지 알아야 연결을 시도할 수 있기 때문이다. 

![image](https://user-images.githubusercontent.com/61526722/198794128-dea75f40-ddbb-4360-b68f-188c24110f64.png)

**TCP(Transmission Control Protocol)**

TCP는 OSI 7계층 중 전송 계층에서 사용되고 있는 프로토콜로, 장비들 간의 통신 과정에서 정보를 안정적으로, 순서대로, 에러없이 교환할 수 있도록 하는 것에 목적을 둔 프로토콜이다. 

OSI 7계층에서는 낮은 계층일수록 기계에 가까운 부분이고 높은 부분일수록 사람에게 가까운 부분이다. 네트워크라는 것이 수많은 기술의 집약체인 만큼 각 계층 간 철저한 역할 분담을 통해 어떤 작업을 할 때 신경써야 하는 범위를 좀혀준다. 따라서 우리는 HTTP를 사용할 때 DNS는 어디를 사용할지, 패킷은 어떻게 처리할지 등 여러 가지 작업을 한번에 신경쓸 필요가 없다.

![image](https://user-images.githubusercontent.com/61526722/198794198-b5ad32c7-f6bc-4eab-b160-9e2443651068.png)

**회선 교환 방식**

옛날에는 통신을 위해 A가 중계국에 “B랑 연결해주세요!”라고 하면, 케이블이 마구 꽂혀있는 패치 테이블에서 A 라벨이 붙은 구멍과 B 라벨이 붙은 구멍을 찾아서 케이블로 연결해주었다. 즉, 회선을 교환하는 방식을 사용했었다. 회선 교환 방식의 경우에는 통신을 하고 싶은 상대방과 물리적으로 회선을 하나 딱 잡아놓고 계속 통신을 하는 것이기 때문에 회선의 효율이 낮을 수 밖에 없다. 회선을 독범하기 때문에 대량의 데이터를 빠른 속도로 보낼 수 있는 장점도 있었지만 전적으로 하나의 회선에 의존하는 연결을 계속할 수 없었다. 그래서 나온 아이디어가 패킷 교환 방식이다. 

**패킷 교환 방식**

회선 교환 방식을 사용할 때, 데이터를 하나의 회선을 사용하여 보내다가 회선이 망가지면 데이터는 모두 손실된다. 패킷 교환 방식은 이 심각한 문제를 방지하기 위해 데이터를 잘게 쪼갠 다음에 여러개의 회선을 통해 보내는 방법을 채택했다. 

![image](https://user-images.githubusercontent.com/61526722/198794263-525d3dc4-937f-44ca-9946-81f8e53dab92.png)

이렇게 하면 하나의 회선이 고장나도 데이터가 약간은 유실될 될 수 있지만 회선 교환 방식 보다는 적은 양의 데이터가 유실된다. 그리고 하나의 회선을 잡아놓고 통신하는 것이 아니라 패킷에 목적지를 알려주고 보내기만 하면 되서 회선의 사용 효율도 높아 졌다. 

**TCP**

하지만 패킷 교환 방식도 아래와 같은 몇 가지 문제가 있었다. 

![image](https://user-images.githubusercontent.com/61526722/198794338-b87787e1-ec7b-484a-86b8-7202fa6e66a3.png)

이 문제를 해결하기 위해 TCP가 등장했다. TCP 헤더에는 다양한 정보들이 들어있는데, 상대방이 보낸 세그먼트의 헤더에 들어있는 정보를 파악하여 작동한다. 

**TCP 헤더**

HTTP, TCP, IP와 같은 프로토콜들은 보내고자 하는 데이터에 자신의 헤더를 붙혀서 데이터의 정보를 표현한다. TCP는 전송의 신뢰성과 흐름 제어, 혼잡 제어 등의 역할을 맡고 있는 프로토콜이기 때문에, TCP 헤더에도 이러한 기능을 사용하기 위한 여러가지 값들이 담겨있다.

TCP는 여러 개의 필드로 나누어진 20 bytes(160 bites)의 헤더를 사용하며, 각 필드의 비트를 0 또는 1로 변경하여 전송하고자 하는 세그먼트의 정보를 나타낸다. 하지만 이 20 bytes라는 것은 아무 옵션도 없는 기본적인 헤더일 때의 용량이고, TCP의 여러가지 옵션들을 사용하면 헤더 맨 뒤에 옵션 필드들이 추가로 붙기 때문에 최대 40 bytes가 더해진 60 bytes까지도 사용할 수도 있다.

![image](https://user-images.githubusercontent.com/61526722/198794411-d9a9ec85-82ec-4b86-bca6-daba571461ee.png)

- Source Port, Destination Port
    - 16 bits
    - 세그먼트의 출발지와 목적지인 포트 번호
    - IP 주소는 네트워크 계층에서 한 계층 밑인 IP의 헤더에 담기기 때문에 port만 기록
- Sequence Number
    - 32 bits
    - 전송하는 데이터의 순서
    - 시퀀스 번호 덕분에, 수신자는 쪼개진 세그먼트의 순서를 파악하여 올바른 순서로 데이터를 재조립할 수 있게 됨
    - 송신자가 최초로 데이터를 전송할 때는 이 번호를 랜덤한 수로 초기화 하며, 이후 자신이 보낼 데이터의 1 bytes당 시퀀스 번호를 1씩 증가시키며 데이터의 순서를 표현하다가 4,294,967,296 을 넘어가면 다시 0부터 시작
- Acknowledge Number
    - 32 bits
    - 승인 번호는 데이터를 받은 수신자가 예상하는 다음 시퀀스 번호를 의미
    - 연결 설정과 연결 해제 때 발생하는 핸드쉐이크 과정에서는 ’상대방이 보낸 시퀀스 번호 +1’ 로 자신의 승인 번호를 만들어내지만, 실제로 데이터를 주고 받을 때는 ’상대방이 보낸 시퀀스 번호 + 자신이 받은 데이터의 bytes’ 로 승인 번호를 만들어냄
- Data Offset
    - 전체 세그먼트 중 헤더가 아닌 데이터가 시작되는 위치 표시
- Window Size
    - 한번에 전송할 수 있는 데이터의 양을 의미하는 값
- Checksum
    - 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값
- Urgent Pointer
    - URG 플래그가 1이면 수신 측은 이 폰인터가 가르키고 있는 데이터를 우선 처리

(TCP) [https://evan-moon.github.io/2019/11/10/header-of-tcp/](https://evan-moon.github.io/2019/11/10/header-of-tcp/)

(IP) [https://evan-moon.github.io/2019/06/22/my-home-to-google/](https://evan-moon.github.io/2019/06/22/my-home-to-google/)

---

### 소켓

네크워크 소켓은 컴퓨터 네트워크의 노드 내에서 데이터를 보내거나 받는 내부 끝점(endpoint)을 의미한다. 리눅스에서 소켓은 I/O 인터페이스의 한 종류이며 네트워크 프로그래밍의 가장 기본적인 부분을 담당한다. 

- 네트워크 도메인 소켓 – 네트워크 주소(IP/PORT)를 통해 통신
- 유닉스 도메인 소켓 – 시스템(호스트)내에서 파일 경로를 통해 통신

---

### TCP 소켓 통신

**TCP 소켓 통신 함수 호출 흐름**

아래와  같이 서버와 클라이언트가 존재할 때 소켓을 생성하고, 운영체제 시스템에 소켓을 부착하여(주소 할당) 외부와의 연결점을 가지게 된다. 그 후에 listen()을 통해서 외부의 TCP 연결을 받아들일 수 있도록 연결 큐를 생성하고 연결 대기를 하게 된다. 이제 클라이언트 쪽에서 대기하고 있는 소켓에 connect로 연결 접속을 시도한다. 클라이언트로 부터 연결 요청이 왔을 때 서버는 accept()로 연결을 수락하여 서버와 클라이언트는 TCP 스트림을 연결한다. 그 후에는 send()와 receive()를 통해 데이터를 주고 받고 데이터 전달이 끝나면 일반적으로 클라이언트쪽에서 먼저 close()로 연결을 종료한다.

![image](https://user-images.githubusercontent.com/61526722/198794505-50c39f96-a90f-418b-aa06-b1a1ffcd16c6.png)

**TCP 소켓 통신 패킷 흐름**

TCP는 전화(연결 지향형), UDP는 편지(비연결 지향형)에 비유를 하곤 한다. TCP는 연결 요청을 보내고 상대방이 누군지 확인하는 작업이 있다면, UDP는 그냥 수신자가 정확한지, 편지가 중간에 사라졌는지, 받아야 하는 사람이 집에 있는지에 상관없이 우체통에 편지를 던져버리면 끝이다. 

TCP는 데이터를 주고 받는 스크림을 연결하기 위해 3-way handshake라는 행위를 한다. 클라이언트에서 대기하고 있는 서버에 연결 요청을 하면서 SYN 메세지를 보내고, 서버는 이를 받고 ACK를 추가하여 응답을 보내준다. 클라이언트는 받은 SYN에 대한 응답인 ACK을 다시 보내준다. 

데이터 송신이 끝난 후에는 4-way handshake라는 행위를 한다. 먼저 연결 종료를 시도하는 측에서 연결을 끊겟다는 의미를 가진 FIN을 보낸다. FIN을 잘 수신받았다는 응답으로 ACK과 나도 그만 끊겠다는 의미를 가진 FIN을 보내준다. 최종적으로 연결 종료를 시도하는 측에서 ACK을 보내면 해당 소켓 통신을 종료된다.  

![image](https://user-images.githubusercontent.com/61526722/198794586-a36a1d89-9d12-432a-89b3-cdbd783b1deb.png)

---

### UDP 소켓 통신

UDP (User Datagram Protocol)는 간단한 메시지 지향 전송 계층 프로토콜이다. UDP는 헤더 및 페이로드의 무결성 검사 (체크섬을 통해)를 제공하지만 메시지 전달 및 UDP에 대해 상위 계층 프로토콜을 보장하지 않는다. 계층은 일단 전송 된 UDP 메시지의 상태를 유지하지 않기 때문에 신뢰할 수 없는 데이터 그램 프로토콜 이라고도 한다. 

![image](https://user-images.githubusercontent.com/61526722/198794673-78f25b0d-dd27-4996-ba30-fafddc2fa89a.png)

TCP는 커넥션을 먼저 맺는 연결 지향형이었다면 UDP 소켓은 비연결 지향형(connectionless), 연결 과정이 없으므로 사용이 간단하고 빠르다. 가벼우므로 실시간성을 요구하는 음성/화상 등 스트리밍 데이터나 많은 수의 클라이언가 접속하는 경우에 많이 사용된다. 이에 반해 전송 확인이 어려우며 재전송 메커니즘 등이 존재하지 않아 신뢰성은 떨어진다. 

![image](https://user-images.githubusercontent.com/61526722/198794749-4033311a-ba79-4c5e-9a84-f24a0d26f1bc.png)

UDP는 연결이 필요없기 때문에 데이터를 송신할 때 목적지의 주소를 지정할 수 있는 sendto()와 송신자의 정보를 받을 수 있는 recvfrom() 함수를 사용하여 단순히 소켓 버퍼에 데이터를 저장한다. 

---

### 유닉스 도메인 소켓

유닉스 도메인 소켓은 도메인의 범위가 유닉스 시스템에 국한된다. 즉 로컬 호스트(자기 자신)에 국한되므로 외부에서 접속할 수 없다. 유닉스 도메인 소켓은 IPC의 개념으로 사용된다.
